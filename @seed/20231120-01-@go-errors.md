# Don't return err in Go

Instead, **add missing details relevant for debugging.**

People, who don't understand Go errors,
like to complain that the language requires writing
tons of "`if err != nil { return err }`" blocks.
Problem is, this is a completely wrong way of error handling in Go; an *antipattern*.

Let's show what I mean on some sample code:
a helper library for configuring an [mTLS](https://en.wikipedia.org/wiki/mTLS#mTLS) connection.
("Mutual TLS" is a way to prove to a server that a client is who they claim to be.)

```golang
package mtls

import (
	"crypto/tls"
	"crypto/x509"
	"fmt"
	"os"
)

type ClientConfig struct {
	CAPath   string
	KeyPath  string
	CertPath string
}

func (c *ClientConfig) BuildTLSConfig() (*tls.Config, error) {
	if *c == (ClientConfig{}) {
		return nil, fmt.Errorf("mtls: cannot build tls.Config from empty ClientConfig")
	}

	ret := &tls.Config{}
	if c.CAPath != "" {
		ca, err := os.ReadFile(c.CAPath)
		if err != nil {
			return nil, fmt.Errorf("mtls: building tls.Config from ClientConfig.CAPath: %w", err)
		}
		pool := x509.NewCertPool()
		pool.AppendCertsFromPEM(ca)
		ret.RootCAs = pool
	}
	if c.KeyPath != "" || c.CertPath != "" {
		cert, err := tls.LoadX509KeyPair(c.CertPath, c.KeyPath)
		if err != nil {
			return nil, fmt.Errorf("mtls: building tls.Config from ClientConfig.KeyPath & .CertPath: %w", err)
		}
		ret.Certificates = []tls.Certificate{cert}
	}
	return ret, nil
}
```
