# First assembly on nRF51822 microcontroller

I'm having [a lot of weird problems](https://github.com/probe-rs/probe-rs/discussions/3175#discussioncomment-12595670)
trying to put Rust programs on an nRF51822 microcontroller,
and to have them run correctly.
I decided I need to try going low level to assembly,
and debugging instruction by instruction.
Going down to "first principles".

I found [a great blog series][sven0]
on writing very simple Cortex-M assembly.
It's written for a Cortex-M4 processor,
but it feels it should not need much adjustment to make it work for a Cortex-M0 one I have.

[sven0]: https://svenssonjoel.github.io/pages-2021/cortex-m-assembler-0/index.html

## The code

Trying [to use](https://github.com/akavel/nrf51822-asm-debugging/blob/a74d9954308432a06e819088e43b513c93c9b7ec/try01/try.s)
the code verbatim from
the [first part of the series][sven0]
resulted in a bunch of errors like below:

```
C:> arm-none-eabi-as -g -mcpu=cortex-m0 -mthumb try.s -o try.o
try.s: Assembler messages:
try.s:26: Error: cannot honor width suffix -- `sub r2,r1,r0'
try.s:34: Error: lo register required -- `add r1,r1,#1'
try.s:35: Error: lo register required -- `add r0,r0,#1'
try.s:37: Error: lo register required -- `sub r2,r2,#1'
try.s:43: Error: cannot honor width suffix -- `ldr r9,=apa'
try.s:44: Error: cannot honor width suffix -- `ldr r9,[r9]'
try.s:47: Error: cannot honor width suffix -- `ldr r8,=0x1337BEEF'
```

After some searching, it seems that
some commands need to be
marked with explicit clarification
that they change the flags registers,
which is done by adding a `s` suffix.
Thus, `sub` needs to become `subs`,
and `add` become `adds`.

Also, on Cortex-M0 (a.k.a. ARMv6-M),
`ldr` can only access registers up to `r7`,
so I needed to tweak those commands
to use lower registers instead of `r8` and `r9`.

Taking into account also some improvements
that were done in subsequent articles in the series,
my code became:

```asm
	.syntax unified
	.cpu cortex-m0
	.thumb

	.global vtable
	.global reset_handler

	.section .text

vtable:
	.word _estack
	.word reset_handler
	.word 0
	.word hardfault_handler
	@ .size vtable, .-vtable

.thumb_func	
hardfault_handler:
	b hardfault_handler
	
.thumb_func	
reset_handler:
	ldr r0, =_estack
	mov sp, r0

	ldr r0, =_dstart
	ldr r1, =_dend

	subs r2,r1,r0

	ldr r1, =_flash_dstart

cpy_loop:
	ldrb r3, [r1]
	strb r3, [r0]

	adds r1, r1, #1
	adds r0, r0, #1

	subs r2, r2, #1
	cmp r2, #0
	bne cpy_loop


main:
	ldr r4, =apa
	ldr r4, [r4]

	ldr r5, =0xF00DF00D
	ldr r6, =0x1337BEEF

done:
	b done

	.section .data

apa:	.word 0xFEEBDAED
```

The linker script also needed to be changed,
I based it on the one used e.g. [in `embassy-nrf`](
https://github.com/embassy-rs/embassy/blob/f15a11f4d69ea905e9feb944969f6b1d1f134e63/examples/nrf51/memory.x):

```
_estack = 0x20010000;

MEMORY
{
FLASH (rx)  : ORIGIN = 0x00000000, LENGTH = 256K
RAM (xrw)   : ORIGIN = 0x20000000, LENGTH = 16K
}


SECTIONS
{

.text : {
      *(.text)
}>FLASH

_flash_dstart = .;

.data :  {
      _dstart = .;
      *(.data)
      _dend = .;
}>RAM AT> FLASH  /* Load into FLASH, but live in RAM */


} /* SECTIONS END */
```

(I might actually have done stack bad;
given the smaller RAM,
I'm now pretty sure I need to move it back a tad.
But I'm not actually using it yet,
so I didn't have a chance to be hit by it...)

